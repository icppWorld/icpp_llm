// Candid interface of the canister endpoints
// https://internetcomputer.org/docs/current/references/candid-ref/

type Prompt = record {
  prompt : text;
  steps : nat64;
  temperature : float32;
  topp : float32;
  rng_seed : nat64;
};

// Motoko does not support float32, so we use float64, and then map PromptMo onto Prompt
type PromptMo = record {
  prompt : text;
  steps : nat64;
  temperature : float64;
  topp : float64;
  rng_seed : nat64;
};

type Config = record {
  dim : int;
  hidden_dim : int;
  n_layers : int;
  n_heads : int;
  n_kv_heads : int;
  vocab_size : int;
  seq_len : int;
};

// ----------------------------------------------------------
// New approach to endpoint return values:
// -> wrap a record in a Result

// --
type ApiError = variant {
  InvalidId;
  Other : text;
  StatusCode : nat16;
  ZeroAddress;
};

// --
// Returned by several endpoints.
// HTTPS status code wrapped in a Record wrapped in a Result
type StatusCodeRecordResult = variant {
  Err : ApiError;
  Ok : StatusCodeRecord;
};
type StatusCodeRecord = record { status_code : nat16 };

// --
// Returned by 'set_canister_mode'
type CanisterModeRecordResult = variant {
  Err : ApiError;
  Ok : CanisterModeRecord;
};
type CanisterModeRecord = record { canister_mode : text };

// --
// Returned by 'inference', 'nft_story_start', 'nft_story_continue'
// Section of a story, generated by a single inference call
type InferenceRecordResult = variant {
  Err : ApiError;
  Ok : InferenceRecord;
};
type InferenceRecord = record {
  inference : text;
  num_tokens : nat64;
};

// --
// A story, from beginning, build from multiple inference calls
type StoryRecordResult = variant {
  Err : ApiError;
  Ok : StoryRecord;
};
type StoryRecord = record { story : text };

// --
// Metadata for an NFT collection
type NFTCollectionRecordResult = variant {
  Err : ApiError;
  Ok : NFTCollectionRecord;
};
type NFTCollectionRecord = record {
  nft_supply_cap : nat64;
  nft_total_supply : nat64;
  nft_symbol : text;
  nft_name : text;
  nft_description : text;
};

// --
// Returned by 'get_users'
type UsersRecordResult = variant {
  Err : ApiError;
  Ok : UsersRecord;
};
type UsersRecord = record {
  user_count : nat64;
  user_ids : vec text;
};

// --
// Returned by 'get_user_metadata'

type UserMetadataRecordResult = variant {
  Err : ApiError;
  Ok : UserMetadataRecord;
};
type UserMetadataRecord = record {
  chats_start_time : vec nat64;
  chats_total_steps : vec nat64;
};

// ----------------------------------------------------------

type NFTWhitelistRecord = record {
  id : principal;
  description : text;
};

type NFT = record {
  token_id : text;
};

// --------------------------------------------------------------------------------
// HTTP Gateway Protocol
// https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec#canister-http-interface
// https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec
// https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-candid

type HeaderField = record { text; text };

type HttpRequest = record {
  method : text;
  url : text;
  headers : vec HeaderField;
  body : blob;
  certificate_version : opt nat16;
};

// type HttpUpdateRequest = record {
//     method: text;
//     url: text;
//     headers: vec HeaderField;
//     body: blob;
// };

type HttpResponse = record {
  status_code : nat16;
  headers : vec HeaderField;
  body : blob;
  upgrade : opt bool;
  // streaming_strategy: opt StreamingStrategy;
};

/* StreamingStrategy is NOT YET SUPPORTED
// Each canister that uses the streaming feature gets to choose their concrete
// type; the HTTP Gateway will treat it as an opaque value that is only fed to
// the callback method

type StreamingToken = === application-specific type ===

type StreamingCallbackHttpResponse = record {
    body: blob;
    token: opt StreamingToken;
};

type StreamingStrategy = variant {
    Callback: record {
        callback: func (StreamingToken) -> (opt StreamingCallbackHttpResponse) query;
        token: StreamingToken;
    };
};
*/

service : {
  // canister endpoints
  canister_init : () -> ();
  set_canister_mode : (text) -> (StatusCodeRecordResult);
  health : () -> (StatusCodeRecordResult) query;
  ready : () -> (StatusCodeRecordResult) query;

  // LLM initialization endpoints
  reset_model : () -> (StatusCodeRecordResult);
  reset_tokenizer : () -> (StatusCodeRecordResult);
  upload_model_bytes_chunk : (vec nat8) -> (StatusCodeRecordResult);
  upload_tokenizer_bytes_chunk : (vec nat8) -> (StatusCodeRecordResult);
  initialize : () -> (StatusCodeRecordResult);
  get_model_config : () -> (Config) query;

  // Chat endpoints for canister_mode=chat-principal
  new_chat : () -> (StatusCodeRecordResult);
  inference : (Prompt) -> (InferenceRecordResult);
  inference_mo : (PromptMo) -> (InferenceRecordResult);

  // admin endpoints
  whoami : () -> (text) query;
  get_users : () -> (UsersRecordResult) query;
  get_user_metadata : (text) -> (UserMetadataRecordResult) query;

  // http endpoints
  http_request : (request : HttpRequest) -> (HttpResponse) query;

  // nft endpoints (for canister_mode=nft-ordinal)
  nft_whitelist : (NFTWhitelistRecord) -> (StatusCodeRecordResult);
  nft_ami_whitelisted : () -> (StatusCodeRecordResult);
  nft_init : (NFTCollectionRecord) -> (StatusCodeRecordResult);
  nft_metadata : () -> (NFTCollectionRecordResult) query;
  nft_mint : (NFT) -> (StatusCodeRecordResult);
  nft_story_start : (NFT, Prompt) -> (InferenceRecordResult);
  nft_story_start_mo : (NFT, PromptMo) -> (InferenceRecordResult);
  nft_story_continue : (NFT, Prompt) -> (InferenceRecordResult);
  nft_story_continue_mo : (NFT, PromptMo) -> (InferenceRecordResult);
  nft_get_story : (NFT) -> (StoryRecordResult) query;
};
